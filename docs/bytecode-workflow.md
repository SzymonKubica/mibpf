# eBPF Program Compilation Workflow


**Contents**
-   [eBPF Program Compilation
    Workflow](#ebpf-program-compilation-workflow)
    -   [Compilation into eBPF
        bytecode](#compilation-into-ebpf-bytecode)
    -   [Post-processing](#post-processing)
        -   [Extracting the text
            section](#extracting-the-text-section)
        -   [Ahead-of-time bytecode patching and
            relocations](#ahead-of-time-bytecode-patching-and-relocations)
        -   [Relocation resolution at load
            time](#relocation-resolution-at-load-time)

The compilation of an eBPF program for microcontrollers involves:
- first compilation step using `clang` into the llvm bitcode,
- llvm bitcode is compiled into the eBPF object file using `llc`,
- postprocessing step is applied depending on the implementation details
  of the target VM.

## Compilation into eBPF bytecode

The first step of the compilation workflow involves emitting the llvm bitcode
using the command below:
```bash
clang -emit-llvm -c source_file.c -o
```
It creates an output file `source_file.bc` which contains the llvm bitcode and
can be inspected in a human-readable way using:

```bash
llvm-dis source_file.bc
```

After the bitcode is generated, it is compiled into the eBPF bytecode using:

```bash
llc -march=bpf -mcpu=v2 -filetype=obj -c source_file.bc
```

Both of the above steps are the same for the two target VMs that we are considering
(rust-based rBPF, and Femto-Containers VM). After that, the compilation workflows
diverge as the the post-processing step is tied to the specifics of what bytecode
format is expected by the target VM.

## Post-processing

After the object file file containing the eBPF bytecode is generated by the `llc`,
it needs to be processed to be compatible with the target VM that is going to
be executing it.

The existing approaches include:
- **extracting the `.text` section** from the ELF file (simple but limits
  compatibility, used by rBPF)
- **patching the bytecode before loading** - works by reordering sections and
  creating a header section specifying the offsets of each section in the
  resulting binary. It is done outside of the target microcontroller before the
  program is sent to the device (used by Femto-Containers).
- **resolving relocations and patching at load time** - approach followed by
  libbpf in case of the Linux kernel, allows for the largest flexibility, however
  could be computationally expensive and complicated to implement.

### Extracting the text section

The simplest way of preparing the bytecode for execution in the target VM is
simply extracting the `.text` section out of the generated ELF file. This approach
was followed by [rbpf](https://github.com/qmonnet/rbpf), the userspace eBPF VM
written in Rust.

This approach is simple as it gives us a program binary where the first instruction
of the program is located at the start of the binary.
It thus requires minimal pre-processing to start executing the VM.

This approach however, has a number of limitations:
- extracting only the `.text` section means that `.data` and `.rodata` sections
  of the ELF file are discarded. This means that e.g. string literals used for
  `printf` in the function invocation are lost,
- the source file cannot contain any non-inlined functions apart from the main
  function.

#### Losing the read-only data and data sections
For example, if our program contained:
```C
printf("Measured temperature: %d", 100);
```
It would compile successfully, however the executing program would no longer
have access to the format string and thus would not be able to use it for
printing (as it lives in the `.rodata` section)
A hacky solution would be to declare the format string explictly, and then
use it, however it limits the space of supported programs as we need to require
that elaborate way of preparing format strings:
```C
char fmt[] = "Measured temperature: %d";
printf(fmt, 100);
```
This could be partially fixed by introducing a macro which always handles
printf using that explicit declaration.
```C
#define print(format, ...)                                                     \
do {                                                                           \
    char fmt[] = format;                                                       \
    bpf_printf(fmt, __VA_ARGS__);                                              \
} while(0);
  ```
The reason why explicit declaration without the read-only data sections works is
that the compiler emits code that stores the format strings on the stack. For
example, if we compile the following code:
```C
char fmt[] = "printf accepts up to 4 args: %d %d %d %d\n";
bpf_printf(fmt, 1, 2, 3, 4);
```
The emitted bytecode looks as follows:

```
   0:   b7 01 00 00 0a 00 00 00         mov %r1,10
   8:   6b 1a f8 ff 00 00 00 00         stxh [%r10-8],%r1
  10:   18 01 00 00 25 64 20 25         lddw %r1,7216209592422786085
  18:   00 00 00 00 64 20 25 64
  20:   7b 1a f0 ff 00 00 00 00         stxdw [%r10-16],%r1
  28:   18 08 00 00 72 67 73 3a         lddw %r8,2334031327234582386
  30:   00 00 00 00 20 25 64 20
  38:   7b 8a e8 ff 00 00 00 00         stxdw [%r10-24],%r8
  40:   18 09 00 00 70 20 74 6f         lddw %r9,6998651134847230064
  48:   00 00 00 00 20 34 20 61
  50:   7b 9a e0 ff 00 00 00 00         stxdw [%r10-32],%r9
  58:   18 06 00 00 63 63 65 70         lddw %r6,8439872645631402851
  60:   00 00 00 00 74 73 20 75
  68:   7b 6a d8 ff 00 00 00 00         stxdw [%r10-40],%r6
  70:   18 07 00 00 70 72 69 6e         lddw %r7,6998706471188394608
  78:   00 00 00 00 74 66 20 61
  80:   7b 7a d0 ff 00 00 00 00         stxdw [%r10-48],%r7
  88:   bf a1 00 00 00 00 00 00         mov %r1,%r10
  90:   07 01 00 00 d0 ff ff ff         add %r1,-48
  98:   b7 02 00 00 01 00 00 00         mov %r2,1
  a0:   b7 03 00 00 02 00 00 00         mov %r3,2
  a8:   b7 04 00 00 03 00 00 00         mov %r4,3
  b0:   b7 05 00 00 04 00 00 00         mov %r5,4
  b8:   85 00 00 00 01 00 00 00         call 1
```
It turns out that the compiler splits the format string into chunks, and then
loads them one-by-one onto the stack using the `lddw` (load double word) instructions.
Step-by-step what happens above is:

- first the format string is loaded into memory at address `%r10-48`, where `%r10`
  represents the frame pointer of the VM. This is done by loading 64b double-word
  chunks of the string onto the stack.
- then the value of the stack (frame) pointer is placed in register `%r1` (the
  first argument to the `bpf_printf` function), after that it is decremented by
  48 to point to the first character in the format string.
  ```
  88:   bf a1 00 00 00 00 00 00         mov %r1,%r10
  90:   07 01 00 00 d0 ff ff ff         add %r1,-48
- after that the remaining arguments to the function are placed in their respective
  registers and the `bpf_printf` helper (with id 1) is called
  ```
  98:   b7 02 00 00 01 00 00 00         mov %r2,1
  a0:   b7 03 00 00 02 00 00 00         mov %r3,2
  a8:   b7 04 00 00 03 00 00 00         mov %r4,3
  b0:   b7 05 00 00 04 00 00 00         mov %r5,4
  b8:   85 00 00 00 01 00 00 00         call 1
  ```
This behaviour works, however it's not what we want the two main issues with it
are:
- the stack of an eBPF VM is limited to 512B, if we had a very large format string,
  this approach would fill up the stack and so the compilation would fail. In fact,
  in this case we are getting the following error message from `llc`:
  ```
  error: printf_large.c:0:0: in function test_printf i32 (ptr): Looks like the BPF stack limit of 512 bytes is exceeded. Please move large on stack variables into BPF per-cpu array map.
  ```
- the programmer needs to use a bespoke macro to make the `bpf_printf` function
behave as intended.

#### No support for functions

If we only extract the `.text` section, we are losing the relocations information
present in the ELF file. If our program is composed out of a set of functions,
then it won't execute correctly, as the resulting object file doesn't include
the addresses of the functions being called. This is because the memory address
of a given function can't be known at compile time, so the compiler inserts calls
to -1 and appends the relocation metadata e.g. as follows:
```
b0:   85 10 00 00 ff ff ff ff         call -1
                        b0: R_BPF_64_32 led_turn_off
```
Given that in the considered approach we only extract the `.text` section, we
are losing that information and so the VM will fail by trying to call a helper
function with id -1 which isn't present in the set of default helper functions.

This issue can be fixed by telling the compiler to inline the functions e.g. :
```C
inline void led_turn_off(bpf_saul_reg_t *led) { led_set_state(led, 0); }
```
However this approach doesn't scale for the use case that we are targeting. If
we wanted to load a moderately complex eBPF program into the target microcontroller,
its program bytecode is stored in RAM and so inlining all functions could lead to
a very large size of the program, which might not fit into the stack of the thread
running the VM.

### Ahead-of-time bytecode patching and relocations

Another approach for preparing the bytecode to be executed by the VM involves
a post-processing step that happens outside of the target device, before the
bytecode gets sent to the microcontrollers. This method was followed by
Femto-Containers, whereby the compilation step involved using a script which
transformed the ELF file into a bespoke format that could be ingested by their
implementation of the eBPF VM.

This approach aims to solve the problem with missing `.rodata` and `.data`
sections that was discussed in the previous section. The difficulty addressed
here is that before the program gets sent to the device and is loaded into its
memory, we cannot determine the addresses of the data stored in the `.rodata`
and `.data` sections, we can only know their offsets relative to the beginning
of the program binary.

Because of this, all load instructions that access data from those sections
cannot use a concrete memory address at compile time and they need to be adjusted
once the location of the program binary is known. We can observe that those
accesses need to be relocated by looking at the object files generated by `llc`.

#### Loading from read-only data section - walkthrough

For example, if we have a program which defines a constant string:
```C
// This string should go into the .rodata section
const char FMT[] = "printf accepts up to 4 args: %d %d %d %d\n";

int test_printf(void *ctx)
{
    bpf_printf(FMT, 9, 10, 11, 12);
    return 0;
}
```
Then the generated object file will contain the following load-double-word
instruction where the target address is 0 and the relocation metadata specifies
that this string is located in the `.rodata` section.
```
 140:   18 01 00 00 00 00 00 00         lddw %r1,0
 148:   00 00 00 00 00 00 00 00
                        140: R_BPF_64_64        FMT
```

If we now examine that section, we can see that it is there indeed.
```
Disassembly of section .rodata:

0000000000000000 <FMT>:
   0:   70 72 69 6e 74 66 20 61
   8:   63 63 65 70 74 73 20 75
  10:   70 20 74 6f 20 34 20 61
  18:   72 67 73 3a 20 25 64 20
  20:   25 64 20 25 64 20 25 64
```
The problem is that unless we actually place the program in the microcontroller
memory, we cannot determine the address from which the string FMT needs to be
loaded.

The solution implemented in case of Femto-Containers involves adding
two new instructions that weren't previously present in the eBPF ISA: `lddwd` and
`lddwr`. Those two correspond to loading a double word from the `.data` and `.rodata`
sections respectively. The opcodes of those 'artificial' instructions are given below:
```
LDDWD_OPCODE = 0xB8
LDDWR_OPCODE = 0xD8
```

The process of bytecode patching in this case involves looking at all `lddw` instructions
in the ELF file generated by `llc`. If they are associated with the relocation
metadata, then the bytecode patching script replaces them with the special
`lddwd` or `lddwr` instructions with the instruction immediate set to the offset
of the loaded data relative to the start of the `.data` and `.rodata` sections
respectively. That way, when the VM interpreter is executing the instructions,
when it encounters the special load-double-word instruction, it knows that it
needs to load the data from an address in memory which equal to the address
of the start of the `.data`/`.rodata` sections plus the offset specified by
the instruction immediate operand.

Additionally, in order to make all of this work, the bytecode patching script
prepares the header of the program bytecode and writes it before the contents
of all of the sections into the resulting binary. This header structure contains
the following fields:

```C
typedef struct __attribute__((packed)) {
    uint32_t magic;      /**< Magic number */
    uint32_t version;    /**< Version of the application */
    uint32_t flags;
    uint32_t data_len;   /**< Length of the data section */
    uint32_t rodata_len; /**< Length of the rodata section */
    uint32_t text_len;   /**< Length of the text section */
    uint32_t functions;  /**< Number of functions available */
} f12r_header_t;
```
Once this information is available in the generated binary, it can be loaded
into the target device, and the VM interpreter first extracts it out of the
program bytecode, and then is able to use this information to correctly compute
the addresses of the data stored in `.data` and `.rodata` sections. This is
because the VM knows the address of where the program bytecode was loaded into
memory, as well as it knows the lengths of the corresponding sections and their
order, so it is able to compute the offets relative to the start of the program
binary.

#### Limitations of the appoach
Problems with the suggested solution are the following:
- we need to introduce the new instructions to the eBPF ISA
- it introduces coupling between the bytecode preparation script and the implementation
  of the VM (magic lddw instructions)
- the current implementation of the script Femto-Containers cannot handle constant
  strings which aren't placed in the `.rodata` sections (e.g. `printf` problem from before)
  ```
### Relocation resolution at load time

The final, most sophisticated approach is to perform that relocation resolution
step directly on the device. This would require the need for a custom pre-processing
step before the program can be sent to the target device.

This would require adapting the workflow that libbpf is using for loading eBPF
programs into the Linux kernel:

- Open phase: this step involves libbpf parsing the BPF object file and finding BPF
maps, BPF programs, and global variables. After a BPF app is opened, user space
apps can make additional adjustments before all the entities
are created and loaded.

- Load phase: in this step libbpf creates BPF maps, **resolves various relocations**,
and verifies and loads BPF programs into the kernel.

- Attachment phase: In this phase, libbpf attaches BPF programs to various BPF
hook points

- Tear down phase: In the tear down phase, libbpf detaches BPF programs and
unloads them from the kernel. BPF maps are destroyed, and all the resources
used by the BPF app are freed.

See the documentation of [libbpf](https://libbpf.readthedocs.io/en/latest/libbpf_overview.html) for more details.

In our case we would be interested in replicating the second step of the workflow
by resolving the relocations directly on the target device.

#### Evaluation

The immediate advantages would be:
- increased compatibility by being able to send unprocessed object files to the
  target device
- removal of the pre-processing step (simpler workflow for users loading programs)
- no need for custom instructions

However, this comes with a number of challenges:
- relocation logic needs to be implemented to run on the embedded device
- the computational cost of that operation needs to be considered (e.g. RAM required
  for bytecode patching might limit compatibility)
- the raw object files might be too large to send to the target device

**Size concerns**

Before implementing this solution, it is important to estimate if it is even feasible,
I had a look at the object file vs binary file sizes and it looks like the ELF
files are much larger. One idea I had to reduce the discrepancy was to somehow
strip off the debug information present in the object files and see how the size
compares afterwards.

```
-rw-r--r-- 1 szymon szymon 1266 Feb 29 16:43 fmt-helpers.bin
-rw-r--r-- 1 szymon szymon 7656 Feb 29 16:43 fmt-helpers.o
-rw-r--r-- 1 szymon szymon  794 Feb 29 16:43 gcoap.bin
-rw-r--r-- 1 szymon szymon 9600 Feb 29 16:43 gcoap.o
-rw-r--r-- 1 szymon szymon  186 Feb 29 16:43 gpio.bin
-rw-r--r-- 1 szymon szymon  226 Feb 29 16:43 gpio_long.bin
-rw-r--r-- 1 szymon szymon 5144 Feb 29 16:43 gpio_long.o
-rw-r--r-- 1 szymon szymon 4640 Feb 29 16:43 gpio.o
```
It looks like there is a large difference in size, so there are two pathways from
here:

- try to remove redundant information in the ELF files (configure llc to produce object
files without debug strings)
- come up with an intermediate representation akin to what FemtoContainers were
using but in a way that preserves all relocation information so that it can be
done on the target device.






