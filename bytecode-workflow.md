# eBPF Program Compilation Workflow


**Contents**
-   [eBPF Program Compilation
    Workflow](#ebpf-program-compilation-workflow)
    -   [Compilation into eBPF
        bytecode](#compilation-into-ebpf-bytecode)
    -   [Post-processing](#post-processing)
        -   [Extracting the text
            section](#extracting-the-text-section)
        -   [Ahead-of-time bytecode patching and
            relocations](#ahead-of-time-bytecode-patching-and-relocations)
        -   [Relocation resolution at load
            time](#relocation-resolution-at-load-time)

The compilation of an eBPF program for microcontrollers involves:
- first compilation step using `clang` into the llvm bitcode,
- llvm bitcode is compiled into the eBPF object file using `llc`,
- postprocessing step is applied depending on the implementation details
  of the target VM.

## Compilation into eBPF bytecode

The first step of the compilation workflow involves emitting the llvm bitcode
using the command below:
```bash
clang -emit-llvm -c source_file.c -o
```
It creates an output file `source_file.bc` which contains the llvm bitcode and
can be inspected in a human-readable way using:

```bash
llvm-dis source_file.bc
```

After the bitcode is generated, it is compiled into the eBPF bytecode using:

```bash
llc -march=bpf -mcpu=v2 -filetype=obj -c source_file.bc
```

Both of the above steps are the same for the two target VMs that we are considering
(rust-based rBPF, and Femto-Containers VM). After that, the compilation workflows
diverge as the the post-processing step is tied to the specifics of what bytecode
format is expected by the target VM.

## Post-processing

After the object file file containing the eBPF bytecode is generated by the `llc`,
it needs to be processed to be compatible with the target VM that is going to
be executing it.

The existing approaches include:
- **extracting the `.text` section** from the ELF file (simple but limits
  compatibility, used by rBPF)
- **patching the bytecode before loading** - works by reordering sections and
  creating a header section specifying the offsets of each section in the
  resulting binary. It is done outside of the target microcontroller before the
  program is sent to the device (used by Femto-Containers).
- **resolving relocations and patching at load time** - approach followed by
  libbpf in case of the Linux kernel, allows for the largest flexibility, however
  could be computationally expensive and complicated to implement.

### Extracting the text section

The simplest way of preparing the bytecode for execution in the target VM is
simply extracting the `.text` section out of the generated ELF file. This approach
was followed by [rbpf](https://github.com/qmonnet/rbpf), the userspace eBPF VM
written in Rust.

This approach is simple as it gives us a program binary where the first instruction
of the program is located at the start of the binary.
It thus requires minimal pre-processing to start executing the VM.

This approach however, has a number of limitations:
- extracting only the `.text` section means that `.data` and `.rodata` sections
  of the ELF file are discarded. This means that e.g. string literals used for
  `printf` in the function invocation are lost,
- the source file cannot contain any non-inlined functions apart from the main
  function.

#### Losing the read-only data and data sections
For example, if our program contained:
```C
printf("Measured temperature: %d", 100);
```
It would compile successfully, however the executing program would no longer
have access to the format string and thus would not be able to use it for
printing (as it lives in the `.rodata` section)
A hacky solution would be to declare the format string explictly, and then
use it, however it limits the space of supported programs as we need to require
that elaborate way of preparing format strings:
```C
char fmt[] = "Measured temperature: %d";
printf(fmt, 100);
```
This could be partially fixed by introducing a macro which always handles
printf using that explicit declaration.
```C
#define print(format, ...)                                                     \
do {                                                                           \
    char fmt[] = format;                                                       \
    bpf_printf(fmt, __VA_ARGS__);                                              \
} while(0);
  ```
The reason why explicit declaration without the read-only data sections works is
that the compiler emits code that stores the format strings on the stack. For
example, if we compile the following code:
```C
char fmt[] = "printf accepts up to 4 args: %d %d %d %d\n";
bpf_printf(fmt, 1, 2, 3, 4);
```
The emitted bytecode looks as follows:

```
   0:   b7 01 00 00 0a 00 00 00         mov %r1,10
   8:   6b 1a f8 ff 00 00 00 00         stxh [%r10-8],%r1
  10:   18 01 00 00 25 64 20 25         lddw %r1,7216209592422786085
  18:   00 00 00 00 64 20 25 64
  20:   7b 1a f0 ff 00 00 00 00         stxdw [%r10-16],%r1
  28:   18 08 00 00 72 67 73 3a         lddw %r8,2334031327234582386
  30:   00 00 00 00 20 25 64 20
  38:   7b 8a e8 ff 00 00 00 00         stxdw [%r10-24],%r8
  40:   18 09 00 00 70 20 74 6f         lddw %r9,6998651134847230064
  48:   00 00 00 00 20 34 20 61
  50:   7b 9a e0 ff 00 00 00 00         stxdw [%r10-32],%r9
  58:   18 06 00 00 63 63 65 70         lddw %r6,8439872645631402851
  60:   00 00 00 00 74 73 20 75
  68:   7b 6a d8 ff 00 00 00 00         stxdw [%r10-40],%r6
  70:   18 07 00 00 70 72 69 6e         lddw %r7,6998706471188394608
  78:   00 00 00 00 74 66 20 61
  80:   7b 7a d0 ff 00 00 00 00         stxdw [%r10-48],%r7
  88:   bf a1 00 00 00 00 00 00         mov %r1,%r10
  90:   07 01 00 00 d0 ff ff ff         add %r1,-48
  98:   b7 02 00 00 01 00 00 00         mov %r2,1
  a0:   b7 03 00 00 02 00 00 00         mov %r3,2
  a8:   b7 04 00 00 03 00 00 00         mov %r4,3
  b0:   b7 05 00 00 04 00 00 00         mov %r5,4
  b8:   85 00 00 00 01 00 00 00         call 1
```
It turns out that the compiler splits the format string into chunks, and then
loads them one-by-one onto the stack using the `lddw` (load double word) instructions.
Step-by-step what happens above is:

- first the format string is loaded into memory at address `%r10-48`, where `%r10`
  represents the frame pointer of the VM. This is done by loading 64b double-word
  chunks of the string onto the stack.
- then the value of the stack (frame) pointer is placed in register `%r1` (the
  first argument to the `bpf_printf` function), after that it is decremented by
  48 to point to the first character in the format string.
  ```
  88:   bf a1 00 00 00 00 00 00         mov %r1,%r10
  90:   07 01 00 00 d0 ff ff ff         add %r1,-48
- after that the remaining arguments to the function are placed in their respective
  registers and the `bpf_printf` helper (with id 1) is called
  ```
  98:   b7 02 00 00 01 00 00 00         mov %r2,1
  a0:   b7 03 00 00 02 00 00 00         mov %r3,2
  a8:   b7 04 00 00 03 00 00 00         mov %r4,3
  b0:   b7 05 00 00 04 00 00 00         mov %r5,4
  b8:   85 00 00 00 01 00 00 00         call 1
  ```
This behaviour works, however it's not what we want the two main issues with it
are:
- the stack of an eBPF VM is limited to 512B, if we had a very large format string,
  this approach would fill up the stack and so the compilation would fail. In fact,
  in this case we are getting the following error message from `llc`:
  ```
  error: printf_large.c:0:0: in function test_printf i32 (ptr): Looks like the BPF stack limit of 512 bytes is exceeded. Please move large on stack variables into BPF per-cpu array map.
  ```
- the programmer needs to use a bespoke macro to make the `bpf_printf` function
behave as intended.

#### No support for functions

If we only extract the `.text` section, we are losing the relocations information
present in the ELF file. If our program is composed out of a set of functions,
then it won't execute correctly, as the resulting object file doesn't include
the addresses of the functions being called. This is because the memory address
of a given function can't be known at compile time, so the compiler inserts calls
to -1 and appends the relocation metadata e.g. as follows:
```
b0:   85 10 00 00 ff ff ff ff         call -1
                        b0: R_BPF_64_32 led_turn_off
```
Given that in the considered approach we only extract the `.text` section, we
are losing that information and so the VM will fail by trying to call a helper
function with id -1 which isn't present in the set of default helper functions.

This issue can be fixed by telling the compiler to inline the functions e.g. :
```C
inline void led_turn_off(bpf_saul_reg_t *led) { led_set_state(led, 0); }
```
However this approach doesn't scale for the use case that we are targeting. If
we wanted to load a moderately complex eBPF program into the target microcontroller,
its program bytecode is stored in RAM and so inlining all functions could lead to
a very large size of the program, which might not fit into the stack of the thread
running the VM.

### Ahead-of-time bytecode patching and relocations

### Relocation resolution at load time
